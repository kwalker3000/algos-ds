
#ifndef _doubleNode_h
#define _doubleNode_h

template <class T> class DoubleNode {

public:
    // <T> not required in constructor
    DoubleNode();
    // DoubleNode(T const data); // will cause ambiguity with other constructor
    // below
    DoubleNode(T const data, DoubleNode<T> *prevNode = nullptr,
               DoubleNode<T> *nextNode = nullptr);

    T get() const;
    DoubleNode<T> *next() const;
    DoubleNode<T> *prev() const;

    // Should the outside client have access?
    DoubleNode<T> *m_next, *m_prev;

private:
    T m_data;
};

template <class T> DoubleNode<T>::DoubleNode()
{
    m_prev = nullptr;
    m_next = nullptr;

    // this could be are head or tail pointer?
}

// template <class T> // must go before each method
// DoubleNode<T>::DoubleNode(T const data)
// {
//     this->data = data;
//     this->prev = nullptr;
//     this->next = nullptr;
// }

// more functional style as only used passed in arguments
template <class T>
DoubleNode<T>::DoubleNode(T const data, DoubleNode<T> *prevNode,
                          DoubleNode<T> *nextNode)
{
    m_data = data;
    m_prev = prevNode;
    m_next = nextNode;
}

template <class T> T DoubleNode<T>::get() const
{
    return m_data;
}

template <class T> DoubleNode<T> *DoubleNode<T>::next() const
{
    return m_next;
}

template <class T> DoubleNode<T> *DoubleNode<T>::prev() const
{
    return m_prev;
}

#endif

// struct node {
//     int value;
//     node* next;
//     node* prev;
// }
